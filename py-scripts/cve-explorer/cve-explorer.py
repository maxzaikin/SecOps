# cve_explorer.py
# Script for exploring known cve vulnerabilities.
# Includes CPE name and full traceability data in the output.

import argparse
import os
import time
from datetime import datetime

import pandas as pd
import requests
from dotenv import load_dotenv
from requests.auth import HTTPProxyAuth
from requests.exceptions import HTTPError, RequestException

load_dotenv()

# --- 1. Configuration Section ---
# All user-configurable parts are grouped here for easy access.

# --- API Keys (REQUIRED) ---
# Get your NVD API key from: https://nvd.nist.gov/developers/request-an-api-key
NVD_API_KEY = os.getenv("NVD_API_KEY")

if not NVD_API_KEY:
    raise RuntimeError("Missing NVD_API_KEY in .env file")

# Get your MITRE API key from: https://www.cve.org/ProgramFundamentals/About/RequestAPIKey
MITRE_API_KEY = os.getenv("MITRE_API_KEY")

# --- API Endpoints ---
NVD_CPE_API_URL = "https://services.nvd.nist.gov/rest/json/cpes/2.0"
NVD_CVE_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
MITRE_API_URL = "https://cveawg.mitre.org/api/cve"

# --- Script Configuration ---
CSV_FILE = "vulnerabilities_log.csv"
NVD_REQUEST_DELAY_SECONDS = 1

# --- Proxy Configuration ---
USE_PROXY = False
PROXY_URL = "http://proxy.yourdomain.local:8080"
PROXY_USER = "domain\\username"
PROXY_PASS = "password"

# --- Helper function for robust API requests ---
def make_api_request(url, **kwargs):
    proxies = {"http": PROXY_URL, "https": PROXY_URL} if USE_PROXY else None
    auth = HTTPProxyAuth(PROXY_USER, PROXY_PASS) if USE_PROXY else None

    headers = kwargs.get("headers", {})
    if "nvd.nist.gov" in url and NVD_API_KEY:
        headers["apiKey"] = NVD_API_KEY
    kwargs["headers"] = headers

    try:
        response = requests.get(url, proxies=proxies, auth=auth, timeout=30, **kwargs)
        response.raise_for_status()
        return response.json()
    except HTTPError as e:
        print(f"[!] HTTP Error for {url}: {e.response.status_code} - {e.response.text}")
    except RequestException as e:
        print(f"[!] Network or Request Error for {url}: {e}")
    return None

# --- CPE & CVE Fetching Logic ---
def find_cpe_for_software(software, version):
    print(f"[NVD] Searching for CPE for '{software} {version}'...")
    if not NVD_API_KEY:
        print("[!] NVD API key is missing. Cannot search for CPE.")
        return None

    print("[+] NVD API Key found.")

    params = {"keywordSearch": f"{software} {version}", "resultsPerPage": 1}
    data = make_api_request(NVD_CPE_API_URL, params=params)

    if data and data.get("products"):
        cpe_name = data["products"][0]["cpe"]["cpeName"]
        print(f"[+] CPE found: {cpe_name}")
        return cpe_name
    else:
        print(f"[-] Could not automatically determine CPE for '{software} {version}'.")
        return None

def get_cves_by_cpe(cpe_name):
    print(f"[NVD] Searching for CVEs for CPE: {cpe_name}...")

    all_cves = []
    start_index = 0
    results_per_page = 2000 # Max allowed by NVD API

    while True:
        params = {"cpeName": cpe_name, "startIndex": start_index, "resultsPerPage": results_per_page}
        data = make_api_request(NVD_CVE_API_URL, params=params)

        if not data or not data.get("vulnerabilities"):
            break

        vulnerabilities = data["vulnerabilities"]
        all_cves.extend(vulnerabilities)

        print(f"    - Found {len(vulnerabilities)} vulnerabilities on this page, processing...")

        if len(vulnerabilities) < results_per_page:
            break

        start_index += len(vulnerabilities)
        time.sleep(NVD_REQUEST_DELAY_SECONDS)

    print(f"[+] Total {len(all_cves)} CVEs found. Parsing details...")
    return [parse_nvd_vulnerability(item, cpe_name) for item in all_cves]

def get_mitre_cves(software, version):
    if not MITRE_API_KEY:
        print("[~] Skipping MITRE search - no API key found.")
        return []

    print(f"[MITRE] Searching CVEs for: '{software} {version}'...")
    print("[+] MITRE API Key found.")

    params = {"keywordSearch": f"{software} {version}"}
    headers = {"Authorization": f"Bearer {MITRE_API_KEY}"}
    data = make_api_request(MITRE_API_URL, headers=headers, params=params)

    if not data or not data.get("cves"):
        print("[-] MITRE API returned no results.")
        return []

    print(f"[+] Found {len(data['cves'])} results from MITRE. Parsing details...")
    return [parse_mitre_vulnerability(item) for item in data.get("cves", [])]

def parse_nvd_vulnerability(vuln_item, cpe_name):
    cve = vuln_item.get("cve", {})
    description = next((d["value"] for d in cve.get("descriptions", []) if d["lang"] == "en"), "")

    cvss_score, severity, attack_vector = None, None, None
    metrics = cve.get("metrics", {}).get("cvssMetricV31", [])
    if metrics:
        cvss_data = metrics[0].get("cvssData", {})
        cvss_score = cvss_data.get("baseScore")
        severity = cvss_data.get("baseSeverity")
        attack_vector = cvss_data.get("attackVector")

    return {
        "cve_id": cve.get("id"), "description": description, "published_date": cve.get("published"),
        "source": "NVD", "cvss_score": cvss_score, "severity": severity,
        "attack_vector": attack_vector, "cpe_name": cpe_name
    }

def parse_mitre_vulnerability(vuln_item):
    metadata = vuln_item.get("cveMetadata", {})
    containers = vuln_item.get("containers", {}).get("cna", {})
    description = next((d["value"] for d in containers.get("descriptions", []) if d["lang"] == "en"), "")

    return {
        "cve_id": metadata.get("cveId"), "description": description, "published_date": metadata.get("datePublished"),
        "source": "MITRE", "cvss_score": None, "severity": None, 
        "attack_vector": None, "cpe_name": "N/A (MITRE)"
    }

# --- CSV Data Handling ---
def append_to_csv(software, version, records):
    if not records:
        print("[~] No new valid records to add.")
        return

    # Define the full set of columns to ensure order and completeness
    CSV_COLUMNS = [
        "recorded_at", "software", "version", "source", "cpe_name", "cve_id", 
        "severity", "cvss_score", "attack_vector", "description", "published_date"
    ]

    try:
        if os.path.exists(CSV_FILE) and os.path.getsize(CSV_FILE) > 0:
            existing_df = pd.read_csv(CSV_FILE)
            existing_cve_ids = set(zip(existing_df["software"], existing_df["version"], existing_df["cve_id"]))
        else:
            existing_df = pd.DataFrame(columns=CSV_COLUMNS)
            existing_cve_ids = set()
    except (pd.errors.EmptyDataError, FileNotFoundError):
        existing_df = pd.DataFrame(columns=CSV_COLUMNS)
        existing_cve_ids = set()

    new_rows = []
    date_now = datetime.now().isoformat(timespec='seconds')
    
    for r in records:
        key = (software, str(version), r.get("cve_id"))
        if r.get("cve_id") and key not in existing_cve_ids:
            # Create a new dictionary with all columns to ensure correct order
            row_data = {col: None for col in CSV_COLUMNS}
            row_data.update({
                "recorded_at": date_now,
                "software": software,
                "version": version,
                "cve_id": r.get("cve_id"),
                "description": r.get("description"),
                "cvss_score": r.get("cvss_score"),
                "severity": r.get("severity"),
                "attack_vector": r.get("attack_vector"),
                "published_date": r.get("published_date"),
                "source": r.get("source"),
                "cpe_name": r.get("cpe_name")
            })
            new_rows.append(row_data)

    if not new_rows:
        print("[~] All found CVEs are already in the log.")
        return

    df_new = pd.DataFrame(new_rows)[CSV_COLUMNS] # Ensure column order
    header = not os.path.exists(CSV_FILE) or existing_df.empty
    df_new.to_csv(CSV_FILE, mode='a', index=False, header=header)
    print(f"[+] {len(df_new)} new entries added to {CSV_FILE}")

# --- Main Execution Logic ---
def main():
    parser = argparse.ArgumentParser(description="Find CVEs using CPE and log them to a CSV file")
    parser.add_argument("--app", required=True, help="Software name (e.g., 'log4j')")
    parser.add_argument("--ver", required=True, help="Software version (e.g., '2.14.1')")
    parser.add_argument("--source", choices=['nvd', 'mitre'], default='nvd', help="Primary data source ('nvd' or 'mitre')")
    args = parser.parse_args()

    print(f"--- CVE Explorer v3: Searching for {args.app} {args.ver} from source '{args.source}' ---")

    results = []
    if args.source == 'nvd':
        cpe_name = find_cpe_for_software(args.app, args.ver)
        if cpe_name:
            results = get_cves_by_cpe(cpe_name)
    elif args.source == 'mitre':
        results = get_mitre_cves(args.app, args.ver)

    append_to_csv(args.app, args.ver, results)
    print("--- Run Complete ---")


if __name__ == "__main__":
    main()
